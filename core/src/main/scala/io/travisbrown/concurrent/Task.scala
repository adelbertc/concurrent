package io.travisbrown.concurrent

import cats.{ Applicative, Eval, MonadError, MonoidK, Traverse }
import cats.data.Xor
import cats.std.list._

import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.atomic.{ AtomicBoolean, AtomicInteger }

import scala.collection.JavaConversions._
import scala.concurrent.duration._
import scala.util.control.NonFatal

/*
 * `Task[A]` is a `Future[Xor[Throwable, A]]`,
 * with some convenience functions for handling exceptions. Its
 * `Monad` and `Nondeterminism` instances are derived from [[Future]].
 *
 * `Task` (and `Future`) differ in several key ways from the `Future`
 * implementation in Scala 2.10 , and have a number of advantages. See the
 * documentation for [[Future]] for more information.
 *
 * `Task` is exception-safe when constructed using the primitives
 * in the companion object, but when calling the constructor, you
 * are responsible for ensuring the exception safety of the provided
 * `Future`.
 */
final class Task[A](val get: Future[A]) { self =>
  def flatMap[B](f: A => Task[B]): Task[B] = new Task(
    get.flatMap(a =>
      try f(a).get catch {
        case NonFatal(error) => Future.fail(error)
      }
    )
  )

  def map[B](f: A => B): Task[B] = new Task(
    get.flatMap(a =>
      try Future.now(f(a)) catch {
        case NonFatal(error) => Future.fail(error)
      }
    )
  )

  /** 'Catches' exceptions in the given task and returns them as values. */
  def attempt: Task[Xor[Throwable, A]] = new Task(get.attempt)

  /**
   * Returns a new `Task` in which `f` is scheduled to be run on completion.
   * This would typically be used to release any resources acquired by this
   * `Task`.
   */
  def onFinish(f: Option[Throwable] => Task[Unit]): Task[A] = new Task(
    get.attempt.flatMap {
      case Xor.Left(error) => f(Some(error)).get.flatMap(_ => Future.fail(error))
      case Xor.Right(value) => f(None).get.map(_ => value)
    }
  )

  /**
   * Calls `attempt` and handles some exceptions using the given partial
   * function, calling Task.now on the result. Any nonmatching exceptions
   * are reraised.
   */
  def handleErrorWith(f: Throwable => Task[A]): Task[A] = attempt.flatMap {
    case Xor.Right(value) => Task.now(value)
    case Xor.Left(error) => f(error)
  }

  /**
   * Runs this `Task`, and if it fails with an exception, runs `t2`.
   * This is rather coarse-grained. Use `attempt`, `handle`, and
   * `flatMap` for more fine grained control of exception handling.
   */
  def or[B >: A](t2: Task[B]): Task[B] = attempt.flatMap {
    case Xor.Right(value) => Task.now(value)
    case Xor.Left(_) => t2
  }

  /**
   * Run this `Task` and block until its result is available. This will
   * throw any exceptions generated by the `Task`. To return exceptions
   * in an `\/`, use `attemptRun`.
   */
  def unsafePerformSync: A = get.attempt.unsafePerformSync match {
    case Xor.Left(e) => throw e
    case Xor.Right(a) => a
  }

  /** Like `run`, but returns exceptions as values. */
  def unsafePerformSyncAttempt: Xor[Throwable, A] = get.run

  /**
   * Run this computation to obtain an `A`, so long as `cancel` remains false.
   * Because of trampolining, we get frequent opportunities to cancel
   * while stepping through the trampoline, this should provide a fairly
   * robust means of cancellation.
   */
  def unsafePerformAsyncInterruptibly(f: Xor[Throwable, A] => Unit, cancel: AtomicBoolean): Unit =
    get.attempt.unsafePerformAsyncInterruptibly(
      new ResultCallback[Xor[Throwable, A]] {
        def onValue(x: Xor[Throwable, A]): Unit = f(x)
        def onError(error: Throwable): Unit = f(Xor.left(error))
      },
      cancel
    )

  /**
   * Similar to `unsafePerformAsyncInterruptibly(f,cancel)` except instead of interrupting by setting cancel to true,
   * It returns the function, that, when applied will interrupt the task.
   *
   * This allows "deterministic" completion of task computation
   * even if it was interrupted.
   * That means task will complete even when interrupted,
   * but with `TaskInterrupted` exception.
   *
   * Note 1: When Interrupted, the `f` callback will run in thread that called the `Interrupting` function () => Unit
   * Note 2: If task has handler like attempt, it won't get consulted for handling TaskInterrupted excpetion
   * @param f
   * @return
   */
  def unsafePerformAsyncInterruptibly(f: Xor[Throwable, A] => Unit) : () => Unit = {
    val completed: AtomicBoolean = new AtomicBoolean(false)
    val actor = Actor.rethrowing[Option[Xor[Throwable, A]]] {
      case Some(r) if !completed.get =>
        completed.set(true)
        f(r)
      case None if !completed.get =>
        completed.set(true)
        f(Xor.left(Task.TaskInterrupted))
      case _ => () //already completed
    }(Strategy.Sequential)

    get.unsafePerformAsyncInterruptibly(
      new ResultCallback[A] {
        final def onValue(a: A): Unit = actor(Some(Xor.right(a)))
        final def onError(error: Throwable): Unit = actor(Some(Xor.left(error)))
      },
      completed
    )

    () => actor(None)
  }

  /**
   * Run this computation to obtain either a result or an exception, then
   * invoke the given callback. Any pure, non-asynchronous computation at the
   * head of this `Task` will be forced in the calling thread. At the first
   * `Async` encountered, control to whatever thread backs the `Async` and
   * this function returns immediately.
   */
  def unsafePerformAsync(f: Xor[Throwable, A] => Unit): Unit = get.unsafePerformAsync(
    new ResultCallback[A] {
      final def onValue(a: A): Unit = f(Xor.right(a))
      final def onError(error: Throwable): Unit = f(Xor.left(error))
    }
  )

  /**
   * Run this `Task` and block until its result is available, or until
   * `timeoutInMillis` milliseconds have elapsed, at which point a `TimeoutException`
   * will be thrown and the `Task` will attempt to be canceled.
   */
  def unsafePerformSyncFor(timeoutInMillis: Long): A = get.attempt.unsafePerformSyncFor(timeoutInMillis) match {
    case Xor.Left(e) => throw e
    case Xor.Right(a) => a
  }

  def unsafePerformSyncFor(timeout: Duration): A = unsafePerformSyncFor(timeout.toMillis)

  /**
   * Like `unsafePerformSyncFor`, but returns exceptions as values. Both `TimeoutException`
   * and other exceptions will be folded into the same `Throwable`.
   */
  def unsafePerformSyncAttemptFor(timeoutInMillis: Long): Xor[Throwable, A] =
    get.unsafePerformSyncAttemptFor(timeoutInMillis)

  def unsafePerformSyncAttemptFor(timeout: Duration): Xor[Throwable, A] =
    unsafePerformSyncAttemptFor(timeout.toMillis)

  /** Ensures that the result of this Task satisfies the given predicate, or fails with the given value. */
  def ensure(failure: => Throwable)(f: A => Boolean): Task[A] =
    flatMap(a => if (f(a)) Task.now(a) else Task.fail(failure))
}

final object Task { self =>
  implicit final val taskInstance: Nondeterminism[Task] with MonadError[Task,Throwable] =
    new Nondeterminism[Task] with MonadError[Task, Throwable] {
      private[this] val F: Nondeterminism[Future] = Nondeterminism[Future]
      def pure[A](a: A): Task[A] = Task.now(a)
      override def pureEval[A](a: Eval[A]): Task[A] = Task.delay(a.value)
      override def map[A, B](fa: Task[A])(f: A => B): Task[B] = fa.map(f)
      def flatMap[A, B](fa: Task[A])(f: A => Task[B]): Task[B] = fa.flatMap(f)
      def chooseAny[A](h: Task[A], t: Seq[Task[A]]): Task[(A, Seq[Task[A]])] = new Task(
        Future.intoFailed(
          F.map(F.chooseAny(h.get, t.map(_.get)).attempt)(
            _.map {
              case (a, residuals) => (a, residuals.map(new Task(_)))
            }
          )
        )
      )

      def chooseAnyIndexed[A](fs: IndexedSeq[Indexed[Task[A]]]): Task[(Indexed[A], IndexedSeq[Indexed[Task[A]]])] =
        new Task(
          Future.intoFailed(
            F.map(F.chooseAnyIndexed(fs.map(i => new Indexed(i.a.get, i.i))).attempt)(
              _.map {
                case (ia, residuals) =>
                  (new Indexed(ia.a, ia.i), residuals.map(ri => new Indexed(new Task(ri.a), ri.i)))
              }
            )
          )
        )

      override def gatherUnorderedIndexed[A](fs: IndexedSeq[Indexed[Task[A]]]): Task[List[Indexed[A]]] = new Task(
        Future.intoFailed(
          F.map(F.gatherUnorderedIndexed(fs.map(i => new Indexed(i.a.get.attempt, i.i))))(eithers =>
            Traverse[List].traverseU(eithers)(ri => ri.a.map(a => new Indexed(a, ri.i)))
          )
        )
      )

      override def gatherUnordered[A](fs: Seq[Task[A]]): Task[List[A]] = new Task(
        Future.intoFailed(
          F.map(F.gatherUnordered(fs.map(_.get.attempt)))(eithers => Traverse[List].sequenceU(eithers))
        )
      )

      override def attempt[A](a: Task[A]): Task[Xor[Throwable, A]] = a.attempt
      def tailrecM[A, B](f: A => Task[Xor[A, B]])(a: A): Task[B] = Task.tailrecM(f)(a)
      def raiseError[A](e: Throwable): Task[A] = fail(e)
      def handleErrorWith[A](fa: Task[A])(f: Throwable => Task[A]): Task[A] = fa.handleErrorWith(f)
    }

  /** signals task was interrupted **/
  case object TaskInterrupted extends InterruptedException {
    override def fillInStackTrace: Throwable = this
  }

  val Unit: Task[Unit] = now(())

  /** A `Task` which fails with the given `Throwable`. */
  def fail[A](e: Throwable): Task[A] = new Task(Future.fail(e))

  /** Convert a strict value to a `Task`. Also see `delay`. */
  def now[A](a: A): Task[A] = new Task(Future.now(a))

  /**
   * Promote a non-strict value to a `Task`, catching exceptions in
   * the process. Note that since `Task` is unmemoized, this will
   * recompute `a` each time it is sequenced into a larger computation.
   * Memoize `a` with a lazy value before calling this function if
   * memoization is desired.
   */
  def delay[A](a: => A): Task[A] = suspend(now(a))

  /**
   * Produce `f` in the main trampolining loop, `Future.step`, using a fresh
   * call stack. The standard trampolining primitive, useful for avoiding
   * stack overflows.
   */
  def suspend[A](a: => Task[A]): Task[A] = new Task(
    Future.suspend(
      Xor.catchNonFatal(a.get.attempt) match {
        case Xor.Left(e) => Future.fail(e)
        case Xor.Right(f) => Future.intoFailed(f)
      }
    )
  )

  /**
   * Create a `Task` from an asynchronous computation, which takes the form
   * of a function with which we can register a callback. This can be used
   * to translate from a callback-based API to a straightforward monadic
   * version.
   */
  def async[A](register: (Xor[Throwable, A] => Unit) => Unit): Task[A] = new Task(
    Future.intoFailed(
      Future.async(cb => register(cb.onValue))
    )
  )

  /**
   * Like `Nondeterminism[Task].gatherUnordered`, but if `exceptionCancels` is true,
   * exceptions in any task try to immediately cancel all other running tasks. If
   * `exceptionCancels` is false, in the event of an error, all tasks are run to completion
   * before the error is returned.
   * @since 7.0.3
   */
  def gatherUnordered[A](tasks: Seq[Task[A]], exceptionCancels: Boolean = false): Task[List[A]] =
    if (!exceptionCancels)
      Nondeterminism[Task].gatherUnordered[A](tasks)
    else
      reduceUnordered[A](tasks, exceptionCancels)

  def reduceUnordered[A](tasks: Seq[Task[A]], exceptionCancels: Boolean = false): Task[List[A]] =
    if (!exceptionCancels) taskInstance.reduceUnordered[A](tasks)
    else tasks match {
      // Unfortunately we cannot reuse the future's combinator
      // due to early terminating requirement on task
      // when task fails.  This also makes implementation a bit trickier
      case Seq() => Task.now(Nil)
      case Seq(t) => t.map(List(_))
      case _ => new Task(
          new Async[List[A]] {
            final def onFinish(cb: RunnableResultCallback[List[A]]): Unit = {
              val interrupt = new AtomicBoolean(false)
              val results = new ConcurrentLinkedQueue[List[A]]
              val togo = new AtomicInteger(tasks.size)

              val callback = new RunnableResultCallback[A] {
                final def onValue(a: A): Runnable = {
                  // Try to reduce number of values in the queue
                  val front = results.poll()
                  if (front == null) results.add(List(a)) else results.add(a :: front)

                  // only last completed f will hit the 0 here.
                  if (togo.decrementAndGet() == 0)
                    cb.onValue(results.toList.foldLeft[List[A]](Nil)(_ ::: _))
                  else Future.emptyRunnable
                }

                final def onError(error: Throwable): Runnable = {
                  // Only allow the first failure to invoke the callback, so we
                  // race to set `togo` to 0 here.
                  // If we win, invoke the callback with our error, otherwise, noop
                  @annotation.tailrec
                  def firstFailure: Boolean = {
                    val current = togo.get
                    if (current > 0) {
                      if (togo.compareAndSet(current, 0)) true else firstFailure
                    } else false
                  }

                  if (firstFailure) // invoke `cb`, then cancel any computation not running yet
                    // food for thought - might be safe to set the interrupt first
                    // but, this may also kill `cb(e)`
                    // could have separate AtomicBooleans for each task
                    new Runnable {
                      def run(): Unit = {
                        cb.onError(error).run()
                        interrupt.set(true)
                      }
                    } else Future.emptyRunnable
                }
              }

              tasks.foreach {
                _.get.listenInterruptibly(callback, interrupt)
              }
            }
          }
      )
    }

  def fromOption[A](ma: Option[A])(t: => Throwable): Task[A] = ma.fold[Task[A]](Task.fail(t))(Task.now)

  def fromXor[A <: Throwable, B](x: Xor[A, B]): Task[B] = x.fold(Task.fail, Task.now)

  def tailrecM[A, B](f: A => Task[Xor[A, B]])(a: A): Task[B] = f(a).flatMap {
    case Xor.Left(a0) => tailrecM(f)(a0)
    case Xor.Right(b) => now(b)
  }

  /** type for Tasks which need to be executed in parallel when using an Applicative instance */
  type ParallelTask[A] = Parallel[Task, A]

  /** This Applicative instance runs Tasks in parallel.
   *
   * It is different from the Applicative instance obtained from Monad[Task] which runs tasks sequentially.
   */
  implicit val taskParallelApplicativeInstance: Applicative[ParallelTask] = taskInstance.parallel
}

